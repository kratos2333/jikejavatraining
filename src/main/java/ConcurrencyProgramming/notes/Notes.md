# 多线程相关概念
## 什么是并发与并行？
并发（Concurrent）：同一时间段，多个任务都在执行 ，单位时间内不⼀定同时执行。

并行（Parallel）：单位时间内，多个任务同时执行，单位时间内一定是同时执行。并行上限取决
于CPU核数（CPU时间片内50ms）

注意：并发是一种能力，而并行是一种手段。当我们的系统拥有了并发的能力后，代码如果跑在多核
CPU上就可以并行运行。所以咱们会说高并发处理，而不会说高并行处理。并行处理是基于硬件CPU的
是固定的，而并发处理的能力是可以通过设计编码进行提高的。
![img.png](img.png)

## 线程上下文切换会有什么问题
过多的线程并行执行会导致CPU资源的争抢，产生频繁的上下文切换，常常表现为高并发执行时，RT延
长。因此，合理控制上下文切换次数，可以提高多线程应用的运行效率。（也就是说线程并不是越多越
好，要合理的控制线程的数量。）

- 直接消耗：指的是CPU寄存器需要保存和加载，系统调度器的代码需要执行
- 间接消耗：指的是多核的cache之间得共享数据，间接消耗对于程序的影响要看线程工作区操作数
据的大小

## 线程状态：一个线程的一生
- NEW(新建) ：线程刚被创建，但是并未启动
- RUNNABLE(可运行)：线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没
有，这取决于操作系统处理器
- BLOCKED(锁阻塞)：当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程
进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态
- WAITING(无限等待)：一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting
状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能
够唤醒
- TIMED_WAITING(计时等待)：同waiting状态，有几个方法有超时参数，调用他们将进入Timed
Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有
Thread.sleep 、Object.wait
- TERMINATED(被终止)：因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法
而死亡
![img_1.png](img_1.png)
  
wait()与sleep()区别：
- 主要区别：sleep()方法没有释放锁，而wait()方法释放了锁
- wait()通常用于线程间的交互/通信，sleep()通常用于暂停线程执行
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象的notify或notifyAll。
- sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long)超时后，线程也会自动苏醒

# 线程安全问题
## 什么是线程安全
如果有多个线程在同时执行，而多个线程可能会同时运行一行代码。如果程序每次运行结果和单线程运
行的结果一样，且其他的变量的值也和预期一样，就是线程安全的，反之则是线程不安全的。


## 怎么解决这个问题呢
- 线程同步
- volatile
- JUC
  - 原子类（CAS）
  - 锁（AQS）

# 多线程并发的3个特性
并发编程中，三个非常重要的特性：原子性，有序性和可见性
1. 原子性(Atomicity)：即一个操作或多个操作，要么全部执行，要么就都不执。执行过程中，不能被打断
2. 有序性(Ordering)：程序代码按照先后顺序执行
   为什么会出现无序问题呢？因为指令重排 (Instruction reordering)
3. 可见性(Visibility)：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到
   修改的值
   为什么出现不可见性问题呢？可以说是因为Java内存模型【JMM】

# 可见性
## 可见性案例：Java内存模型（JMM）
JMM线程操作内存的基本规则：

第一条，关于线程与主内存：线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直
接从主内存中读写

第二条，关于线程间本地内存：不同线程之间无法直接访问其他线程本地内存中的变量，线程间变
量值的传递需要经过主内存
![img_2.png](img_2.png)

## 什么是内存可见性
可见性是一个线程对共享变量值的修改，能够及时的被其他线程看到。
线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：
1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

## happens-before规则
- 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
- 锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

## 同步原理剖析
synchronized是如何实现同步的呢？
同步操作主要是monitorenter和monitorexit这两个jvm指令实现的

## 什么是Monitor
Monitor中文翻译为管程，也有人称之为“监视器”，管程指的是管理共享变量以及对共享变量的操
作过程，让他们支持并发。

Java中的所有对象都可以作为锁，每个对象都与一个 monitor 相关联，线程可以对 monitor 执行
lock 和 unlock 操作

## 什么是锁优化？
如果只有一个线程运行时并没有发生资源竞争、或两个线程交替执行，使用传统锁机制无疑效率是
会比较低的。

JDK1.6中为了减少这两个场景，获得锁和释放锁带来的性能消耗，同步锁进行优化引入：偏向锁和
轻量级锁。

同步锁一共有四种状态，级别从低到高依次是：无锁，偏向锁，轻量级锁，重量级锁。这四种状态
会随着竞争激烈情况逐渐升级。

偏向锁
偏向锁则是基这样一个想法：只有一个线程访问锁资源（无竞争）的话，偏向锁就会把整个同步措施都
消除，并记录当前持有锁资源的线程和锁的类型。

轻量级锁
轻量级锁是基于这样一个想法：只有两个线程交替运行时，如果线程竞争锁失败了，先不立即挂起，而
是让它飞一会儿（自旋）spin lock，在等待过程中，可能锁就被释放了，这时该线程就可以重新尝试获取锁，同
时记录持有锁资源的线程和锁的类型。

## volatile
Java允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线
程应该确保通过排他锁单独获得这个变量。

volatile可以保证多线程场景下变量的可见性和有序性。如果某变量用volatile修饰，则可以确
保所有线程看到变量的值是一致的。

volatile will synchronize the thread local memory to the public memory to make sure the visiblity

## volatile缺陷：原子性Bug

volatile适合使用场景

变量真正独立于其他变量和自己以前的值，在单独使用的时候，适合用volatile

对变量的写入操作不依赖其当前值：例如++和--运算符的场景则不行
该变量没有包含在具有其他变量的不变式中

synchronized和volatile比较
volatile不需要加锁，比synchronized更轻便，不会阻塞线程
synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性
与synchronized相比volatile是一种非常简单的同步机制

# 并发编程
## JUC (java.util.concurrent)
![img_3.png](img_3.png)